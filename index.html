<h1>hello world</h1>
<p>
<h2>im html
</h2>
</P>
Мотивация
<h3>h3</h3>
<h4>h4</h4>
<h5>h5</h5>
<h6>h6</h6>
<p>
    Я, как технический директор, регулярно сталкиваюсь с необходимостью обсудить с командой архитектуру нового
    приложения
    или микросервиса. <br /> И в рамках таких обсуждений я понял, что не существует единого подхода, который
    позволил бы
    эффективно общаться команде, обсуждая архитектурные решения.
</p>
<p>
    Понятно, что на словах это не объяснишь и приходится прибегать к дополнительным инструментам в виде доски и
    маркера
    или же при текущих реалиях - online доски типа Miro. Но даже в этом случае обсуждение сваливается в хаотично
    нарисованные
    квадратики, круги или прямоугольники с текстом, как-то соединённые стрелками.
</p>
При этом от обсуждения к обсуждению одна и так же схема может быть нарисована 1000 разными способами. Кто-то в
творческом порыве начинает рисовать иконки пользователей или серверов, а кто-то рисует поток из 10 стрелок, чтобы
показать все возможные варианты взаимодействия. И это - не эффективная коммуникация, где одно и тоже можно понять
по-разному при этом потратив какое-то время на пояснение чем шестиугольник отличается круга.
</p>
<p>
    А что есть?
    Осознав проблемы я первым делом начал искать готовые варианты. Вот несколько из них:
</p>
Диаграмма классов - иногда бывает удобной для анализа уже существующего кода, но не применима для изначального
проектирования, где мы оперируем более верхне уровневыми объектами.
c4model - уже ближе к теме и предлагает 4 уровня детализации схемы программного обеспечения. Но часто из всех 4-х
уровней подходит 3-й, когда мы планируем новый сервис, а на 3-м уровне стандартов описания немного. Отлично подходит
для
верхнего уровня описания системы, но при детализации на компоненты не имеет детальных стандартов.
Потому после нескольких экспериментов, я решил подготовить простую нотацию, которая позволит описать архитектуру
приложений на том уровне, чтобы мы могли:
<p>
    Разбить создание его на задачи.
    Проверить корректность деления на модули, чтобы сократить их связанность.
    Упростить коммуникацию в команде при обсуждении деталей проектирования приложения.
    Использовать её для документирования архитектуры как монолита, так и микросервисов.
</p>